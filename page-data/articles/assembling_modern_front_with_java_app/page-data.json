{"componentChunkName":"component---src-templates-general-js","path":"/articles/assembling_modern_front_with_java_app","result":{"data":{"markdownRemark":{"frontmatter":{"image":{"publicURL":"/static/jakob-owens-235219-unsplash-efffe88a49d859a3f3d67c14936feb0d.jpg"},"title":"Assemble modern front to java app","path":"/articles/assembling_modern_front_with_java_app"},"html":"<h1>Assembling modern front-end with Java app</h1>\n<p>Previously lots of Java powered web systems had their interface written through <code>jsp</code> files or some template engines like\nFreemarker or Thymeleaf. Using those starts to be painful when it comes to writing more complex applications, not even mentioning\nthe SPA or PWA with them. Probably the strongest pain with those solutions is the need of full page reload to every requested URL path.<br>\nThen we were introduced to modern front-end frameworks, making the front-end development a little bit easier and natively creating the\nuser web interface more performant.</p>\n<p>The new struggle came with packaging the builds from those front-end frameworks to the Java web application binaries.</p>\n<h2>The simplest way</h2>\n<p>Such way could be done by running some commands through console, which would build and copy the front build files to some kind of <code>webapp</code> or <code>static</code> directory\nof the Java app, and then build the server app.<br>\nUsing the console commands while working with Java is, from the definition, a bad idea, because it results in writing system specific scripts.<br>\nWhats more, such front-end frameworks relies on the NodeJS (and one of its package manager) for almost all of their needs.</p>\n<p>Other way would be to keep all front-end resources and code in the root project directory or under the resources web of server app,\nbut this would make our project structure harder to manage and understand. Imagine the mess and possible conflicts if the project\nwould have separate front-end and back-end teams.  </p>\n<h2>A \"better\" way</h2>\n<p>Nowadays, the usage of automation build tools for development of any kind of app is a standard practice.<br>\nSuch tools are taking away the struggles with dependency management, cleaning/testing project and allows to build much more complex\nsolutions with little configuration requirement.</p>\n<p>Within the project configuration files of such tools, developing and packaging the front-end builds gets much simpler.     </p>\n<blockquote>\n<p>The examples provided in this article were made with the use of Gradle (6.0.1 version), Spring and Preact.\nIt's possible to make similar configuration with Maven. To do so, you would need to use alike plugins and configure it properly. </p>\n<p>It's recommended to use Gradle because it makes the configuration much smaller and allows to create some useful goals/tasks without\nusing more additional plugins.<br>\nCheck out the <a href=\"//TODO::link_to_understanding_gradle_when_published\">article about gradle</a> which covers basics of Gradle features and migration from Maven.</p>\n</blockquote>\n<p>The final look of working configuration will depend on your current project structure, specific build requirements and the java web frameworks being in use.<br>\nAligning it to your needs shouldn't complicated, take a look at article linked above to see how you could amend the build phase accordingly to your needs.</p>\n<h2>Prerequisites</h2>\n<p>As mentioned, the Gradle, but some of IDEs like IntelliJ IDEA comes with bundled Gradle installation.<br>\nFew assumptions for provided examples in the next sections of this article are:</p>\n<ul>\n<li>\n<p>The project is made within multiple modules, for example having structure similar to:</p>\n<pre><code>Root project 'j-root'\n+--- Project ':j-web'\n\\--- Project ':j-server'\n</code></pre>\n</li>\n<li>There are no sources in the root project</li>\n<li><code>j-server</code> module contains sources for Java application using Spring framework</li>\n<li><code>j-web</code> module is the root of front-end application source and uses Yarn as package manager</li>\n<li>both modules are managed through Gradle (being included in settings script and having their own <code>build.gradle</code> files)</li>\n</ul>\n<p>With all of those the structure of root project should be similar to (some files were omitted):</p>\n<pre><code class=\"language-text\">j-root\n|   build.gradle\n|   settings.gradle\n+---assets\n|   |   favicon.ico\n|   \\---icons //omitted the icon list to maintain readability\n+---j-web\n|   |    build.gradle\n|   |    package.json\n|   +---src\n|   |       index.js\n|   |       style.css\n+---j-server\n    |    build.gradle\n    \\---src\n         \\---main (having `java/pac.kage/Application.java` under it)\n</code></pre>\n<p>As mentioned earlier, changing the configuration to your project needs should take only a little bit of elbow grease.<br>\nThe parts requiring amendment probably will be the project and module name, paths and task dependencies.<br>\nIf you are new to Gradle, refer to the <a href=\"//TODO::link_to_understanding_gradle_when_published\">\"Understanding Gradle\"</a> article.  </p>\n<h2>Let's get started</h2>\n<h4>Configuring the front-end module</h4>\n<p>To allow the usage of <code>node</code> and <code>npm</code> in Gradle tasks, the additional plugin is needed.<br>\nAdd the below to the top of <code>build.gradle</code> in front-end module:</p>\n<pre><code class=\"language-text\">plugins {\n    id \"com.github.node-gradle.node\" version \"2.2.0\"\n}\n</code></pre>\n<p>This plugins allows for easy integration with NodeJS, Npm and Yarn tools.<br>\nBelow the <code>plugins</code> block add:</p>\n<pre><code class=\"language-text\">node {\n    version = '13.2.0' \n    yarnVersion = '1.19.2'\n//  npmVersion = '2.1.5'  //this for npm\n    download = true\n}\n</code></pre>\n<p>This is the plugin configuration block, it determines the tool version used with the plugin.<br>\nWithout having the <code>download = true</code>, the plugin will try to use globally installed NodeJS.</p>\n<p>Next is to add gradle tasks which executes the front-end commands (to front module build script):</p>\n<pre><code>task build(type: YarnTask) {\n    group = 'build'\n    description = 'Build the client bundle'\n    dependsOn('yarn')\n    args = ['run', 'build']\n}\ntask test(type: YarnTask) {\n    group = 'verification'\n    description = 'Run the client tests'\n    dependsOn('yarn')\n    args = ['run', 'test']\n}\n</code></pre>\n<p>Kind of self descriptive, isn't it?<br>\nSimilarly, you can add different tasks covering the <code>run</code> commands contained in your <code>package.json</code> file.<br>\nNow running the <code>gradlew build</code> from root project will execute the build command defined in <code>package.json</code> file.</p>\n<p>To make <code>npm</code> task, the <code>type: NpmTask</code> should be used and script name changed accordingly to the one you have in <code>package.json</code>.</p>\n<p>For more information take a look at the <a href=\"https://github.com/node-gradle/gradle-node-plugin/blob/master/docs/node.md\">plugin documentation</a> page.  </p>\n<h4>Packaging to the server</h4>\n<p>With assumed project structure there is no need the change the build script of the server.<br>\nBut if your root project contains the java web app sources, then you just need to change the task dependencies to refer to root project.  </p>\n<p>Add the following tasks to the build script of root project:</p>\n<pre><code class=\"language-text\">task copyClientResources {\n    dependsOn(':j-web:build') //builds front-end at first\n    doFirst {\n        copy {\n            from project(':j-web').buildDir.absolutePath\n            into \"${project(':j-server').buildDir}/resources/main/static\"\n        }\n    }\n}\ntask assembleServerAndClient {\n    group = 'build' //shows task in 'build' group\n    dependsOn(copyClientResources) //runs this task before itself\n    finalizedBy(':j-server:build') //finalizes execution with provided task\n    //both of the above could be replaced with single:\n    //dependsOn(copyClientResources, ':j-server:build')\n}\n</code></pre>\n<p>Now, running the <code>assembleServerAndClient</code> will build and copy front-end files to the static resources of server, which\nwill be packed into binary generated by <code>build</code> task of server module.<br>\nIf your root project is the Java app you can use <code>${rootProject.buildDir}/resources/main/static</code> as the <code>into</code> copy path\nand refer to its build task with simple <code>finalizedBy(build)</code>.  </p>\n<p>The copy paths may vary on your configuration. For example the Micronaut framework serves the static content from <code>resources/main/public</code> path\nand uses the ShadowJar plugin to build binaries with dependencies.</p>\n<h3>Few tips</h3>\n<p>Jumping through windows to start/stop the Java server or front-end development server, might be painful.<br>\nAnd it would be better to be able to manage it with Gradle tasks.<br>\nFor starting the development of server such task can be added to build script of front-end module:</p>\n<pre><code class=\"language-text\">task startDevFront(type: YarnTask) {\n    group = 'application'\n    description = 'Run the client app'\n    dependsOn('yarn')\n    args = ['run', 'dev']\n}\n</code></pre>\n<p>There's one little issue, stopping that gradle task won't stop the Node dev server.<br>\nTo still be able to work through Gradle similar task can be added to front module:</p>\n<pre><code class=\"language-text\">task stopDevFront(type:Exec) {\n    group = 'application'\n    description = 'Stop devFront (kills all node.exe processes)'\n    println 'Discovered Windows system'\n    commandLine 'cmd', '/c', 'taskkill /F /IM node.exe'\n}\n</code></pre>\n<p>The configured <code>commandLine</code> is for Windows OS, but this task can be simply extended to discover on which OS it's running\nand configure proper console command with simple <code>if</code> statements (see this <a href=\"https://stackoverflow.com/questions/11235614/how-to-detect-the-current-os-from-gradle/31443955\">SO question</a>).</p>\n<p>Running the java server with the newest build of front-end can be done with below task added to root build script:</p>\n<pre><code class=\"language-text\">task bootRunWithNewFront {\n    group = 'application'\n    dependsOn(copyFrontToServer)\n    finalizedBy(':j-server:bootRun') //bootRun is the task created by Spring Boot \n}\n</code></pre>\n<h2>Ending word</h2>\n<p>There are many ways of structuring such projects and packaging user web interface made with any modern JS framework to the server application,\nbut many of them leads to overcomplicated structure and the need of making some tweaks while building one or another.<br>\nThe presented approach of using Gradle and making those two a submodules, allows to create separate configurations based on their needs\nand keeps the project structure simple. Additionally, the use of shown plugin reduces the need of preinstalling the Node\nand Gradle tool makes the project and its configurations very minimal.  </p>\n<br />\n<p>Sample project covering described features can be found in this <a href=\"//TODO::add%20link%20to%20minimal%20repo\">github repository</a></p>"}},"pageContext":{"id":"e8fe6f85-b3c2-5df6-9f70-eb59bf48170c"}}}